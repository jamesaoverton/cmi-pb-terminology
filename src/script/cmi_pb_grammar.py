from lark import Transformer

# Grammar used to parse the the contents of `condition` and `structure` columns.
# See: https://lark-parser.readthedocs.io/en/latest/index.html#
grammar = r"""
%import common.WS
%ignore WS

start: expression+
?expression: string | function

?string: label
label: ALPHANUM | DQSTRING

function: function_name "(" arguments ")"
function_name: ALPHANUM
arguments: argument ("," argument)*
?argument: string | field | function | named_arg | regex
field: label "." label
named_arg: label "=" label

?regex: regex_sub | regex_match
regex_match: "/" regex_pattern "/" regex_flags
regex_sub: "s/" regex_pattern "/" regex_pattern "/" regex_flags
regex_pattern: REGEX_WITH_FORWARD_SLASH | REGEX_WITHOUT_FORWARD_SLASH
regex_flags: LOWER_ALPHA*

ALPHANUM: /[a-zA-Z0-9-_]/+
DQSTRING: "\"" /[^"](\\\")?/+ "\""
LOWER_ALPHA: /[a-z]/
NO_SLASH: /[^\/]/
REGEX_WITH_FORWARD_SLASH: NO_SLASH* "\\/" NO_SLASH*
REGEX_WITHOUT_FORWARD_SLASH: NO_SLASH+
"""


class ParsedTreeTransformer(Transformer):
    """Transformer to convert a Tree, generated by the grammar used by CMI-PB to parse the contents
    of `condition` and `structure` columns, into a list of expressions represented as dicts."""

    def _sanity_check(self, token_list, expected_len):
        if len(token_list) != expected_len:
            raise Exception(f"Wrong number of tokens in: {token_list} (expecting {expected_len})")

    def label(self, label):
        self._sanity_check(label, 1)
        label = label[0]
        return {"type": "label", "value": label.value}

    def field(self, field):
        self._sanity_check(field, 2)
        return {"type": "field", "table": field[0]["value"], "column": field[1]["value"]}

    def named_arg(self, named_arg):
        self._sanity_check(named_arg, 2)
        return {"type": "named_arg", "key": named_arg[0]["value"], "value": named_arg[1]["value"]}

    def regex_match(self, regex_match):
        self._sanity_check(regex_match, 2)
        return {"type": "regex", "pattern": regex_match[0], "flags": regex_match[1]}

    def regex_sub(self, regex_sub):
        self._sanity_check(regex_sub, 3)
        return {
            "type": "regex",
            "pattern": regex_sub[0],
            "replace": regex_sub[1],
            "flags": regex_sub[2],
        }

    def regex_flags(self, flags):
        return [flag.value for flag in flags]

    def arguments(self, arguments):
        return arguments

    def function_name(self, function_name):
        self._sanity_check(function_name, 1)
        return function_name[0].value

    def function(self, function):
        self._sanity_check(function, 2)
        return {"type": "function", "name": function[0], "args": function[1]}

    def start(self, start):
        return start
